
use super::idents_us;
use super::idents_eu;
use super::idents_reg;

use super::utils::{execute_sql, execute_phased_transfer, vacuum_table};
use super::idents_utils::{transfer_coded_identifiers, execute_temp_phased_transfer, 
          replace_string_in_ident, remove_both_ldtr_char_from_ident, remove_leading_char_from_ident, 
          switch_number_suffix_to_desc, execute_sql_fb, execute_sql_sfb};

use sqlx::{Pool, Postgres};
use crate::AppError;
use log::info;


/* 
pub async fn build_titles_table (pool: &Pool<Postgres>) -> Result<(), AppError> {  

    let sql = r#"SET client_min_messages TO WARNING; 
    DROP TABLE IF EXISTS ad.study_titles;
    CREATE TABLE ad.study_titles(
      id                     INT             PRIMARY KEY GENERATED ALWAYS AS IDENTITY (start with 10000001 increment by 1)
    , sd_sid                 VARCHAR         NOT NULL
    , title_type_id          INT
    , title_text             VARCHAR
    , lang_code              VARCHAR         NOT NULL default 'en'
    , is_default             BOOL
    , comments               VARCHAR
    , added_on               TIMESTAMPTZ     NOT NULL default now()
    );
    CREATE INDEX study_titles_sid ON ad.study_titles(sd_sid);"#;

	 execute_sql(sql, pool).await?;
    info!("study titles table (re)created");
    Ok(())

}
*/

pub async fn build_idents_table (pool: &Pool<Postgres>) -> Result<(), AppError> {  

        let sql = r#"SET client_min_messages TO WARNING; 
        DROP TABLE IF EXISTS ad.study_identifiers;
        CREATE TABLE ad.study_identifiers(
          id                     INT             NOT NULL GENERATED BY DEFAULT AS IDENTITY
        , sd_sid                 VARCHAR         NOT NULL
        , id_value               VARCHAR         NULL
        , id_type_id             INT             NULL
        , id_type                VARCHAR         NULL
        , source_org_id          INT             NULL
        , source_org             VARCHAR         NULL
        , source_ror_id          VARCHAR         NULL
        , id_date                VARCHAR         NULL
        , id_link                VARCHAR         NULL
        , added_on               TIMESTAMPTZ     NOT NULL default now()
        , coded_on               TIMESTAMPTZ     NULL                                     
        );
        CREATE INDEX study_identifiers_sid ON ad.study_identifiers(sd_sid);"#;

       execute_sql(sql, pool).await?;
        info!("study identifiers table (re)created");


    Ok(())

}


/* 
pub async fn load_titles_data (max_id: u64, pool: &Pool<Postgres>) -> Result<(), AppError> {  

    let chunk_size = 2000000;

    // All studies appear to have a 'brief title'.

    let sql = r#"insert into ad.study_titles (sd_sid, title_type_id, title_text, is_default, comments)
        select nct_id, 15, brief_title, true, 'brief title in clinicaltrials.gov'
        from ctgov.studies c "#;

    execute_phased_transfer(sql, max_id, chunk_size, " where ", "brief titles added", pool).await?;

    let sql = r#"insert into ad.study_titles (sd_sid, title_type_id, title_text, is_default, comments)
        select nct_id, 16, official_title, false, 'official title in clinicaltrials.gov'
        from ctgov.studies c
        where c.official_title is not null and c.official_title <> c.brief_title "#;

    execute_phased_transfer(sql, max_id, chunk_size, " and ", "oficial titles added", pool).await?;

    let sql = r#"insert into ad.study_titles (sd_sid, title_type_id, title_text, is_default)
        select nct_id, 14, acronym, false
        from ctgov.studies c 
        where acronym is not null "#;

    execute_phased_transfer(sql, max_id, chunk_size, " and ", "acronyms added", pool).await?;
    vacuum_table("study_titles", pool).await?;

    Ok(())

}
*/


pub async fn load_idents_data (processing: &str, max_id: u64, pool: &Pool<Postgres>) -> Result<(), AppError> {  

    let chunk_size = 2000000;

    if processing == "full" {

        // Insert the nct ids themselves.
        
        let sql = r#"insert into ad.study_identifiers (sd_sid, id_value, id_type_id, id_type, source_org_id, source_org, id_date)
                                select nct_id, nct_id, 120, 'NCT ID', 100133, 'National Library of Medicine', study_first_posted_date from ctgov.studies c "#;
        execute_phased_transfer(sql, max_id, chunk_size, " where ", "nct ids", "ad.study_identifiers", pool).await?;

        // Insert the old NCT aliases (that have a distinct source id in the ctgov.id_information table). As this is the only insert that makes
        // use of the source_org_id field this allows that field to be ignored and not transferred to the temp_idents table (see below).

        let sql = r#"insert into ad.study_identifiers (sd_sid, id_value, id_type_id, id_type, source_org_id, source_org)
                                select nct_id, id_value, 180, 'Obsolete NCT ID', 100133, 'National Library of Medicine' from ctgov.id_information c where id_source = 'nct_alias' "#;
        execute_phased_transfer(sql, max_id, chunk_size, " and ", "old NCT aliases", "ad.study_identifiers", pool).await?;
    
        // Create a copy of the ctgov identifier table (ad.temp_idents) - 
        // Working with this makes it much easier to develop and test routines 
        // to characterise the identifiers.

        create_copy_of_identifiers(max_id, chunk_size, pool).await?;

        // Using the temp_idents table, tidy up the identifier
        // text and remove duplicates and obvious non identifiers
        
        split_doubled_values(pool).await?;
        tidy_identifier_text(pool).await?;
        remove_obvious_non_identifiers(pool).await?;   // Doing this first simplifies the step below
        make_identifier_prefixes_more_consistent(pool).await?;
        make_identifier_text_more_consistent(pool).await?;
        remove_duplicate_identifiers(pool).await?;  // The data source contains about 11000 duplicated identifiers
        remove_obvious_non_identifiers2(pool).await?; 

        code_very_short_unidentifiable_ids(pool).await?; 
        transfer_coded_identifiers(pool).await?;

        // identify NCI, NIH and other us agency identifiers

        idents_us::find_us_nci_identifiers(pool).await?;
        idents_us::find_us_cdc_identifiers(pool).await?;
        idents_us::find_nih_grant_identifiers(pool).await?;
        idents_us::find_fda_identifiers(pool).await?;
        idents_us::find_other_us_grant_identifiers(pool).await?;
        transfer_coded_identifiers(pool).await?;
       
        park_spare_idents_data(max_id, chunk_size, pool).await?;
    }
    else {
        reuse_spare_idents_data(max_id, chunk_size, pool).await?;
    }

    // Can now start matching against regular expresions representing trial registry formats.

    //idents_reg::find_eudract_registry_identities(pool).await?;
    //idents_reg::find_other_eu_registry_identities(pool).await?;

    idents_eu::find_ansm_identities(pool).await?;
    idents_eu::find_eu_wide_identities(pool).await?;
    idents_eu::find_dutch_identities(pool).await?;
    idents_eu::find_german_identities(pool).await?;
    idents_eu::find_isrctn_identities(pool).await?;
    transfer_coded_identifiers(pool).await?;

    idents_reg::find_japanese_registry_identities(pool).await?;
    idents_reg::find_chinese_registry_identities(pool).await?;
    
    idents_reg::find_other_asian_registry_identities(pool).await?;
    idents_reg::find_middle_eastern_registry_identities(pool).await?;
    idents_reg::find_latin_american_registry_identities(pool).await?;
    idents_reg::find_other_registry_identities(pool).await?;
    //transfer_coded_identifiers(pool).await?;

    // Find non registry Ids, e.g. from funders, regulators, registries
/*
    find_eu_regulators_identities(pool).await?;
    find_ethics_oversight_identities(pool).await?;
    find_other_identities(pool).await?;
    transfer_coded_identifiers(pool).await?;
 */

    let _sql = r#"drop table if exists ad.temp_idents;"#;
    // execute_sql(sql, pool).await?;

    vacuum_table("study_identifiers", pool).await?;

    Ok(())

}


async fn park_spare_idents_data(max_id: u64, chunk_size: u64, pool: &Pool<Postgres>) -> Result<(), AppError> { 
 
    // copy ad.temp_idents to ad.spare_temp_idents

    let sql = r#"SET client_min_messages TO WARNING; 
    drop table if exists ad.spare_temp_idents;
    create table ad.spare_temp_idents
    (
          id                     INT             NOT NULL GENERATED BY DEFAULT AS IDENTITY
        , sd_sid                 VARCHAR         NOT NULL
        , id_value               VARCHAR         NULL
        , id_type_id             INT             NULL
        , id_type                VARCHAR         NULL
        , source_org_id          INT             NULL
        , source_org             VARCHAR         NULL
        , id_class               VARCHAR         NULL
        , id_desc                VARCHAR         NULL
        , id_link                VARCHAR         NULL
    );
    CREATE INDEX spare_temp_idents_id ON ad.spare_temp_idents(id);
    CREATE INDEX spare_temp_idents_sid ON ad.spare_temp_idents(sd_sid);"#;
   execute_sql(sql, pool).await?;

    let sql = r#"insert into ad.spare_temp_idents (id, sd_sid, id_value, id_class, id_desc, id_link)
    select id, sd_sid, id_value, id_class, id_desc, id_link
    from ad.temp_idents c "#;
    execute_temp_phased_transfer(sql, max_id, chunk_size, " where ", "temp_idents", pool).await?;

    // copy ad.study_identiiers to ad.spare_study_identifiers

    let sql = r#"SET client_min_messages TO WARNING; 
        drop table if exists ad.spare_study_identifiers;
        create table ad.spare_study_identifiers(
          id                     INT             NOT NULL GENERATED BY DEFAULT AS IDENTITY
        , sd_sid                 VARCHAR         NOT NULL
        , id_value               VARCHAR         NULL
        , id_type_id             INT             NULL
        , id_type                VARCHAR         NULL
        , source_org_id          INT             NULL
        , source_org             VARCHAR         NULL
        , source_ror_id          VARCHAR         NULL
        , id_date                VARCHAR         NULL
        , id_link                VARCHAR         NULL
        , added_on               TIMESTAMPTZ     NOT NULL default now()
        , coded_on               TIMESTAMPTZ     NULL                                     
        );
        CREATE INDEX spare_study_identifiers_sid ON ad.spare_study_identifiers(sd_sid);"#;
       execute_sql(sql, pool).await?;

    let sql = r#"insert into ad.spare_study_identifiers (id, sd_sid, id_value, 
        id_type_id, id_type, source_org_id, source_org, source_ror_id, id_date, 
        id_link, added_on, coded_on)
        select id, sd_sid, id_value, id_type_id, id_type, source_org_id, source_org, 
        source_ror_id, id_date, id_link, added_on, coded_on
        from ad.study_identifiers c "#;
    execute_temp_phased_transfer(sql, max_id, chunk_size, " where ", "temp_idents", pool).await?;

    let sql = r#"SET client_min_messages TO NOTICE;"#;
   execute_sql(sql, pool).await?;

    Ok(())

}


async fn reuse_spare_idents_data(max_id: u64, chunk_size: u64, pool: &Pool<Postgres>) -> Result<(), AppError> { 

    // Load the data from ad.spare_temp_idents to ad._temp_idents

    let sql = r#"SET client_min_messages TO WARNING; 
	drop table if exists ad.temp_idents;
	create table ad.temp_idents
	(
          id                     INT             NOT NULL GENERATED BY DEFAULT AS IDENTITY
		, sd_sid                 VARCHAR         NOT NULL
        , id_value               VARCHAR         NULL
        , id_type_id             INT             NULL
        , id_type                VARCHAR         NULL
        , source_org_id          INT             NULL
        , source_org             VARCHAR         NULL
        , id_class               VARCHAR         NULL
        , id_desc                VARCHAR         NULL
        , id_link                VARCHAR         NULL
	);
    CREATE INDEX temp_idents_id ON ad.temp_idents(id);
    CREATE INDEX temp_idents_sid ON ad.temp_idents(sd_sid);"#;
   execute_sql(sql, pool).await?;

    let sql = r#"insert into ad.temp_idents (id, sd_sid, id_value, id_class, id_desc, id_link)
    select id, sd_sid, id_value, id_class, id_desc, id_link
    from ad.spare_temp_idents c "#;
    execute_temp_phased_transfer(sql, max_id, chunk_size, " where ", "temp_idents", pool).await?;

    // load the data from ad.spare_study_identifiers to ad.study_identifiers

    let sql = r#"SET client_min_messages TO WARNING; 
        DROP TABLE IF EXISTS ad.study_identifiers;
        CREATE TABLE ad.study_identifiers(
          id                     INT             NOT NULL GENERATED BY DEFAULT AS IDENTITY
        , sd_sid                 VARCHAR         NOT NULL
        , id_value               VARCHAR         NULL
        , id_type_id             INT             NULL
        , id_type                VARCHAR         NULL
        , source_org_id          INT             NULL
        , source_org             VARCHAR         NULL
        , source_ror_id          VARCHAR         NULL
        , id_date                VARCHAR         NULL
        , id_link                VARCHAR         NULL
        , added_on               TIMESTAMPTZ     NOT NULL default now()
        , coded_on               TIMESTAMPTZ     NULL                                     
        );
        CREATE INDEX study_identifiers_sid ON ad.study_identifiers(sd_sid);"#;

       execute_sql(sql, pool).await?;
        info!("study identifiers table (re)created");
        
    let sql = r#"insert into ad.study_identifiers (id, sd_sid, id_value, 
        id_type_id, id_type, source_org_id, source_org, source_ror_id, id_date, 
        id_link, added_on, coded_on)
        select id, sd_sid, id_value, id_type_id, id_type, source_org_id, source_org, 
        source_ror_id, id_date, id_link, added_on, coded_on
        from ad.spare_study_identifiers c "#;
    execute_temp_phased_transfer(sql, max_id, chunk_size, " where ", "temp_idents", pool).await?;

    Ok(())
}


async fn create_copy_of_identifiers(max_id: u64, chunk_size: u64, pool: &Pool<Postgres>) -> Result<(), AppError> { 

    let sql = r#"SET client_min_messages TO WARNING; 
	drop table if exists ad.temp_idents;
	create table ad.temp_idents
	(
          id                     INT             NOT NULL GENERATED BY DEFAULT AS IDENTITY
		, sd_sid                 VARCHAR         NOT NULL
        , id_value               VARCHAR         NULL
        , id_type_id             INT             NULL
        , id_type                VARCHAR         NULL
        , source_org_id          INT             NULL
        , source_org             VARCHAR         NULL
        , id_class               VARCHAR         NULL
        , id_desc                VARCHAR         NULL
        , id_link                VARCHAR         NULL
	);
    CREATE INDEX temp_idents_id ON ad.temp_idents(id);
    CREATE INDEX temp_idents_sid ON ad.temp_idents(sd_sid);"#;
    execute_sql(sql, pool).await?;

	let sql = r#"insert into ad.temp_idents (id, sd_sid, id_value, id_class, id_desc, id_link)
	select id, nct_id, id_value, id_type, id_type_description, id_link
	from ctgov.id_information c where id_source <> 'nct_alias' "#;
    execute_phased_transfer(sql, max_id, chunk_size, " and ", 
        "ctgov identifier records", "ad.temp_idents", pool).await?;

    let sql = r#"SET client_min_messages TO NOTICE;"#;
    execute_sql(sql, pool).await?;
    
    Ok(())
}


async fn split_doubled_values(pool: &Pool<Postgres>) -> Result<(), AppError> {  

    // There seem to be about 720 doubled identifier records, with each
    // pair split by a semi-colon. Not all records with semi-colons are doubles,
    // and some doubled identifiers use a different delimiter, but the semi-colon seems
    // to be a reasonable starting point.

    // As an initial step, remove semi-colons from the start and end of identifiers.

    remove_both_ldtr_char_from_ident(';', pool).await?;

    // First though, a small group of identifiers including '(V/v)ersion' or 'v' followed by a number have a semi-colon 
    // before the date. In these case the semi-colon shopuld just be removed.

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, ';', '')
        where (id_value ilike '%version%'
        or id_value ~ 'v [0-9]' or id_value ~ '^v[0-9]'
        or id_value ~ 'v.[0-9]')
        and id_value ilike '%;%';"#;
   execute_sql(sql, pool).await?;

    // There is a particular group of doubled identifiers that come from the 
    // Clinical Trials Unit in Basel. In each case the first id is a Swiss
    // BASEC (ethics system) number, and the second is an internal CTU
    // identifier. These should be botrh split and identified.
    
    let sql = r#"insert into ad.temp_idents
        (id, sd_sid, id_value, id_class, id_desc)
        select id, sd_sid, trim(substring(id_value, position(';' in id_value) + 1)), id_class, 'Basel CTU ID'
        from ad.temp_idents
        where id_value ~ '; ?[a-z]{2}(1|2)[0-9]{1}[A-Za-z1-5]+$'
        and id_value ~ '[0-9]{4}-[0-9]{5}';"#;
   execute_sql(sql, pool).await?;

    let sql = r#"insert into ad.temp_idents
        (id, sd_sid, id_value, id_class, id_desc)
        select id, sd_sid, trim(substring(id_value, 1, position(';' in id_value) - 1)), id_class, 'BASEC ID'
        from ad.temp_idents
        where id_value ~ '; ?[a-z]{2}(1|2)[0-9]{1}[A-Za-z1-5]+$'
        and id_value ~ '[0-9]{4}-[0-9]{5}';"#;
   execute_sql(sql, pool).await?;

    let sql = r#"delete from ad.temp_idents
        where id_value ~ '; ?[a-z]{2}(1|2)[0-9]{1}[A-Za-z1-5]+$'
        and id_value ~ '[0-9]{4}-[0-9]{5}';"#;
    let res1 = execute_sql(sql, pool).await?;

    // There is a much smaller but similar group of paired records linked by a comma

    let sql = r#"insert into ad.temp_idents
        (id, sd_sid, id_value, id_class, id_desc)
        select id, sd_sid, trim(substring(id_value, position(',' in id_value) + 1)), id_class, 'Basel CTU ID'
        from ad.temp_idents
        where id_value ~ ', ?[a-z]{2}(1|2)[0-9]{1}[A-Za-z1-5]+$'
        and id_value ~ '[0-9]{4}-[0-9]{5}';"#;
   execute_sql(sql, pool).await?;

    let sql = r#"insert into ad.temp_idents
        (id, sd_sid, id_value, id_class, id_desc)
        select id, sd_sid, trim(substring(id_value, 1, position(',' in id_value) - 1)), id_class, 'BASEC ID'
        from ad.temp_idents
        where id_value ~ ', ?[a-z]{2}(1|2)[0-9]{1}[A-Za-z1-5]+$'
        and id_value ~ '[0-9]{4}-[0-9]{5}';"#;
   execute_sql(sql, pool).await?;

    let sql = r#"delete from ad.temp_idents
        where id_value ~ ', ?[a-z]{2}(1|2)[0-9]{1}[A-Za-z1-5]+$'
        and id_value ~ '[0-9]{4}-[0-9]{5}';"#;
    let res2 = execute_sql(sql, pool).await?;

    info!("{} Basel CTU records with semi-colons or commas split", res1.rows_affected() + res2.rows_affected());

    // The remaining semi-colon containing identifiers can then be split and added
    // to the table.

    let sql = r#"insert into ad.temp_idents 
        (id, sd_sid, id_value, id_class, id_desc)
        select id, sd_sid, trim(unnest(string_to_array(id_value, ';'))) as new_value, 
        id_class, id_desc
        from ad.temp_idents
        where id_value ilike '%;%';"#;
    execute_sql(sql, pool).await?;

    let sql = r#"delete from ad.temp_idents 
        where id_value ilike '%;%'"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} remaining records with semi-colons split", res.rows_affected());

    info!("");
    Ok(())
}


async fn tidy_identifier_text(pool: &Pool<Postgres>) -> Result<(), AppError> {  
        
    // Remove single quotes from the beginning and end of identifiers.

    let sql = r#"update ad.temp_idents
        set id_value = trim(BOTH '''' from id_value)
        where id_value like '%''' or id_value like '''%'"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} single quote characters removed from start or end of identifiers", res.rows_affected());

    // Tidy up the spurious characters to be found in the identifiers.

    remove_both_ldtr_char_from_ident('"', pool).await?;
    remove_both_ldtr_char_from_ident('-', pool).await?;
    remove_both_ldtr_char_from_ident(',', pool).await?;
    remove_both_ldtr_char_from_ident('.', pool).await?;
    remove_both_ldtr_char_from_ident('#', pool).await?;

    remove_leading_char_from_ident('!', pool).await?;
    remove_leading_char_from_ident('+', pool).await?;
    remove_leading_char_from_ident('&', pool).await?;
    remove_leading_char_from_ident('*', pool).await?;
    remove_leading_char_from_ident(':', pool).await?;
    remove_leading_char_from_ident('/', pool).await?;
    remove_leading_char_from_ident('|', pool).await?;
    remove_leading_char_from_ident('´', pool).await?;

    replace_string_in_ident(")(", "", pool).await?;
    replace_string_in_ident(" (", " ", pool).await?;
    replace_string_in_ident(") ", " ", pool).await?;
    replace_string_in_ident("(", " ", pool).await?;
    replace_string_in_ident(")", " ", pool).await?;
    replace_string_in_ident("【", " ", pool).await?;
    replace_string_in_ident("】", " ", pool).await?;
    replace_string_in_ident("[", " ", pool).await?;
    replace_string_in_ident("]", " ", pool).await?;
    replace_string_in_ident("--", "-", pool).await?;

    let sql = r#"update ad.temp_idents
        set id_value = substring(id_value, 2)
        where id_value ~ '^_';"#;
    execute_sql(sql, pool).await?;
    info!("{} underscore characters removed from start of identifiers", res.rows_affected());
    info!("");

    // Seems to need to be done twice, albeit for a very small number of records.

    replace_string_in_ident("  ", " ", pool).await?;
    replace_string_in_ident("  ", " ", pool).await?;  

    // Final trim.

    let sql = r#"update ad.temp_idents
        set id_value = trim(id_value);"#;
    execute_sql(sql, pool).await?;
    info!("");

    Ok(())
}


async fn remove_obvious_non_identifiers(pool: &Pool<Postgres>) -> Result<(), AppError> {  

    // Remove those that are almost certainly dummies.

    let sql = r#"delete from ad.temp_idents 
        where 
        id_value in ('0', '00', '000', '0000', '00-000', '00000', '000000', '0000000', 
        '00000000', '000000000', '0000000000', '000000000000', '0000-00000')
        or id_value ilike '%12345678%' 
        or id_value ilike '%87654321%';"#;
    execute_sql_fb(sql, pool, "dummy", "(e.g. all 0s, or obvious sequences) removed").await?;
   

    // Remove those that are too small to be useful (unless type is given).

    let sql = r#"delete from ad.temp_idents 
        where length(id_value) < 3
        and id_desc is not null"#;
    execute_sql_fb(sql, pool, "very short", "(1 or 2 characters) removed").await?;
   
    // Remove those including '@' - e.g. mostly email addresses, plus some odd formulations

    let sql = r#"delete from ad.temp_idents 
        where id_value like '%@%';"#;
    let res = execute_sql(&sql, pool).await?;
    info!("{} email addresses and other odd identifier values with '@' removed", res.rows_affected());

    // Remove identifiers that are study acronyms.

    let sql = r#"delete from ad.temp_idents i
        using ad.study_titles t
        where i.sd_sid = t.sd_sid
        and t.title_type_id = 14
        and upper(i.id_value) = upper(t.title_text);"#;
    execute_sql_sfb(sql, pool, "removed as having the same value as the study acronym").await?;
   
    // Remove identifiers that are study brief titles.

    let sql = r#"delete from ad.temp_idents i
        using ad.study_titles t
        where i.sd_sid = t.sd_sid
        and t.title_type_id in (15, 16)
        and upper(i.id_value) = upper(t.title_text);"#;
    execute_sql_sfb(sql, pool, "removed as having the same value as a study title").await?;

    // Remove identifiers that refer (mostly) to a person.

    let sql = r#"delete from ad.temp_idents i
            where id_value ilike '%dr.%'
            or id_value like '%Dr %'
            or id_value ilike '%prof.%'
            or id_value like '%prof %'
            or id_value like '%Prof %'
            or id_value ilike '%professor%'"#;
    execute_sql_sfb(sql, pool, "removed as referring to a person").await?;

    // Some records have a digit in the id_desc field and only text (inc. spaces and punctuation)
    // in the id_value field. These are generally where the data in the two fields have been inverted
    // on data entry. These need to be swapped back.

    let sql = r#"update ad.temp_idents
        set id_value = id_desc,
        id_desc = id_value
        where id_value ~ '^[A-Za-z\s\.&,_/#-]+$'
        and id_desc ~ '[0-9]'"#;
    let res = execute_sql(&sql, pool).await?;
    info!("{} identifiers and identifier descriptions reversed", res.rows_affected());

    // Some of the swapped group have a date in the id_value field and the type 'No NIH funding'.
    // These need to be removed as not an actual identifier.

    let sql = r#"delete from ad.temp_idents
        where id_desc = 'No NIH funding'"#;
    let res = execute_sql(&sql, pool).await?;
    info!("{}'No NIH funding' records deleted", res.rows_affected());

    // Get rid of all remaining identifiers that include only letters, spaces, and punctuation other than hyphens.
    // Though a few of these may be sponsor Ids the vast bulk are acronyms, the name of the 
    // sponsor or hospital, a short form of the study name, or something undecipherable. 
    // They are not useful identifiers!  
    // Similar terms that include hyphens are retained as a higher percentage of these
    // are possible sponsor ids.
    
    let sql = r#"delete from ad.temp_idents
        where id_value ~ '^[A-Za-z\s\.&,_/]+$'"#;
    execute_sql_sfb(sql, pool, "consisting only of letters, spaces, and certain punctuation removed").await?;
    
    // For future clarity remove id_desc where it is simply the same as the id_value

    let sql = r#"update ad.temp_idents
        set id_desc = null
        where id_desc = id_value"#;
    let res = execute_sql(sql, pool).await?;
    info!("{}' descriptions removed when they are identical to the id value", res.rows_affected());
     
    // Some id_values are simply the trial acronym followed by ' trial', or ' Trial',
    // though there a few exceptions to this general rule, as shown by the sql below.
    // They were not deleted above because the trial name contains a hyphen.

    let sql = r#"delete from ad.temp_idents
        where (id_value ~ ' trial$' or  id_value ~ ' Trial$')
            and id_value !~ '^[0-9]'
            and id_value !~ '^U1111'
            and id_value !~ '^AGO'
            and id_value !~ '^WUCC'"#;
    execute_sql_sfb(sql, pool, "removed when they are simply the trial name followed by ' trial'").await?;
    
    info!("");
    Ok(())

}


async fn make_identifier_prefixes_more_consistent(pool: &Pool<Postgres>) -> Result<(), AppError> {  
    
    // Tries to make the use of the terms like 'number' consistent,
    // Replaces ID, no:, grant no, ref., etc. with the single term 'number'.
    // This is to make it easier to characterise some IDs later, but
    // further processing after these initial steps is done after somne of the 
    // registry IDs have been identiffie and removed (which significantly reduces the numbers involved).

    // Park the bus on these - will restore them later as they are nort easily interpretable

    let sql = r#"update ad.temp_idents
        set id_class = 'temp',
        id_link = id_value
        where id_value in ('No Grant-2', 'no Grant 4', 'No Grant 5', 'no Grant 6')"#;
    execute_sql(sql, pool).await?;
   
    replace_string_in_ident("2024GRANT089", "2024 GRANT 089", pool).await?;
    replace_string_in_ident("BMAChartiableGrant2016", "BMA Charitable Grant 2016", pool).await?;
    info!("");

    replace_string_in_ident("Grant Fund", "grant ", pool).await?;
    replace_string_in_ident("Grant Agreement n.", "grant number ", pool).await?;
    replace_string_in_ident("Grant Agreement Nº:", "grant number ", pool).await?;
    replace_string_in_ident("Grant Agreement", "grant number ", pool).await?;
    replace_string_in_ident("Grant N.", "grant number ", pool).await?;
    replace_string_in_ident("Grant:", "grant ", pool).await?;
    replace_string_in_ident("Grant ID", "grant ", pool).await?;
    replace_string_in_ident("Grant-", "grant ", pool).await?;
    replace_string_in_ident("Grant ", "grant ", pool).await?;
    replace_string_in_ident("GRANT", "grant ", pool).await?;
    replace_string_in_ident("grant:", "grant number ", pool).await?;
    replace_string_in_ident("grant no", "grant number ", pool).await?;
    replace_string_in_ident("grant ", "grant number ", pool).await?;
    replace_string_in_ident("grant,", "grant number ", pool).await?;
    replace_string_in_ident("grant/", "grant number ", pool).await?;
    info!("");

    replace_string_in_ident("PROJECT NUMBER", "project number ", pool).await?;
    replace_string_in_ident("Project Number:", "project number ", pool).await?;
    replace_string_in_ident("Project Number", "project number ", pool).await?;
    replace_string_in_ident("PROJECT NO. ", "project number ", pool).await?;
    replace_string_in_ident("Project n.", "project number ", pool).await?;
    replace_string_in_ident("Project Nr.", "project number ", pool).await?;
    replace_string_in_ident("Project No-", "project number ", pool).await?;
    replace_string_in_ident("Project nº", "project number ", pool).await?;
    replace_string_in_ident("PROJECT NO ", "project number ", pool).await?;
    replace_string_in_ident("Project nr.", "project number ", pool).await?;
    replace_string_in_ident("Project nr", "project number ", pool).await?;
    replace_string_in_ident("project no", "project number ", pool).await?;
    replace_string_in_ident("projectnummer", "project number ", pool).await?;
    replace_string_in_ident("projectnr.", "project number ", pool).await?;
    replace_string_in_ident("projectnr", "project number ", pool).await?;
    replace_string_in_ident("project nr", "project number ", pool).await?;

    replace_string_in_ident("PROJECT00", "project number 00", pool).await?;
    replace_string_in_ident("Project Code:", "project number ", pool).await?;
    replace_string_in_ident("Project ID162820", "project number 162820", pool).await?;
    replace_string_in_ident("ProjectID ", "project number ", pool).await?;
    replace_string_in_ident("Project-ID ", "project number ", pool).await?;
    replace_string_in_ident("Project ID-", "project number ", pool).await?;
    replace_string_in_ident("PROJECT ID:", "project number ", pool).await?;
    replace_string_in_ident("Project id:", "project number ", pool).await?;
    replace_string_in_ident("Project ID:", "project number ", pool).await?;
    replace_string_in_ident("project ID:", "project number ", pool).await?;
    replace_string_in_ident("project-ID", "project number ", pool).await?;

    replace_string_in_ident("Study No", "study number", pool).await?;
    info!("");
    replace_string_in_ident("N°", "number ", pool).await?;
    replace_string_in_ident("n°", "number ", pool).await?;
    replace_string_in_ident(" id ", " number ", pool).await?;
    replace_string_in_ident(" ID ", " number ", pool).await?;

    replace_string_in_ident("Ref. No.", "number ", pool).await?;
    replace_string_in_ident("Ref. No ", "number ", pool).await?;

    replace_string_in_ident("No.", " number ", pool).await?;
    replace_string_in_ident("No:", " number ", pool).await?;
    replace_string_in_ident("No :", " number ", pool).await?;
    replace_string_in_ident("no.", " number ", pool).await?;
    replace_string_in_ident("no:", " number ", pool).await?;
    replace_string_in_ident("no :", " number ", pool).await?;
    replace_string_in_ident("NO :", " number ", pool).await?;
    replace_string_in_ident("NO:", " number ", pool).await?;

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, 'no', ' number ')
        where id_value ~ ' no [0-9]'
        or id_value ~ '^no [0-9]';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} 'no 's folowed by a number replaced with 'number'", res.rows_affected());

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, 'No', ' number ')
        where id_value ~ ' No [0-9]'
        or id_value ~ '^No [0-9]';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} 'No 's folowed by a number replaced with 'number'", res.rows_affected());
    info!("");

    replace_string_in_ident("#:", " number ", pool).await?;
    replace_string_in_ident("# :", " number ", pool).await?;
   
    // Almost all #s can be replaced by a 'number' unless that generates 
    // a split in a number, hi.e. hashes immediately preceded and followed by [0-9] 
    // can cause problems (there are 40-50 examples). It is not clear in these 
    // cases what the # signifies.

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, '#', ' number ')
        where id_value like '%#%'
        and id_value !~ '[0-9]#[0-9]';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} '#'s not embedded in digits replaced with 'number'", res.rows_affected());
    info!("");
     
    replace_string_in_ident("Reference Number", "number ", pool).await?;
    replace_string_in_ident("Reference number", "number ", pool).await?;
    replace_string_in_ident("reference number", "number ", pool).await?;

    replace_string_in_ident("Reference", "number ", pool).await?;
    replace_string_in_ident("REFERENCE", "number ", pool).await?;
    replace_string_in_ident("reference", "number ", pool).await?;
    
    replace_string_in_ident("Ref Nº:", "number ", pool).await?;
    replace_string_in_ident("Ref nº", "number ", pool).await?;
    replace_string_in_ident("Ref No ", "number ", pool).await?;
    replace_string_in_ident("Ref.Nr.", "number ", pool).await?;
    replace_string_in_ident("Ref,", "number ", pool).await?;
    replace_string_in_ident("Ref-Nr:", "number ", pool).await?;
    replace_string_in_ident("Ref Code:", "number ", pool).await?;
    replace_string_in_ident("ref. number ", "number ", pool).await?;
    replace_string_in_ident("Ref. number ", "number ", pool).await?;
    replace_string_in_ident("Ref_ No_ ", "number ", pool).await?;

    replace_string_in_ident("Ref:", "number ", pool).await?;
    replace_string_in_ident("ref:", "number ", pool).await?;
    replace_string_in_ident("Ref.", "number ", pool).await?;
    replace_string_in_ident("ref.", "number ", pool).await?;
    replace_string_in_ident("REF:", "number ", pool).await?;
    replace_string_in_ident(" REF ", "number ", pool).await?;
    replace_string_in_ident(" ref ", "number ", pool).await?;
    replace_string_in_ident(" Ref ", "number ", pool).await?;

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, 'Ref ', '')
        where id_value ~ '^Ref ';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} 'Initial 'Ref's removed", res.rows_affected());
    info!("");

    replace_string_in_ident("agreement", "", pool).await?;
    replace_string_in_ident("  ", " ", pool).await?;

    replace_string_in_ident("number -", " number ", pool).await?;
    replace_string_in_ident("number :", "number ", pool).await?;
    replace_string_in_ident("number:", "number ", pool).await?;
    replace_string_in_ident("number  number", " number ", pool).await?;
    replace_string_in_ident("number number", " number ", pool).await?;
    replace_string_in_ident("number Number", " number ", pool).await?;
    replace_string_in_ident("number NUMBER", " number ", pool).await?;

    // Need to repeat this...

    replace_string_in_ident("  ", " ", pool).await?;
    replace_string_in_ident("  ", " ", pool).await?;

    // repair from the top of the routine
    let sql = r#"update ad.temp_idents
        set id_class = null,
        id_value = id_link,
        id_link = null
        where id_class = 'temp'"#;
    execute_sql(sql, pool).await?;

    // Final trim.

    let sql = r#"update ad.temp_idents
        set id_value = trim(id_value);"#;
    execute_sql(sql, pool).await?;
    info!("");

    Ok(())
}


async fn make_identifier_text_more_consistent(pool: &Pool<Postgres>) -> Result<(), AppError> {  

    // Remove spurious 'number 's that simply prefix an identifier

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, 'number ', '')
        where id_value ~ '^number ';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} Initial 'number's removed", res.rows_affected());
    
    // Create a table with the 'XXX type number' description, and the identifiers themselves, 
    // in separate fields, using those entries that now contain 'number' but which do not have
    // 'number' as the final word.

    let sql = r#"SET client_min_messages TO WARNING; 
            drop table if exists ad.temp_split_numbers;
            create table ad.temp_split_numbers as
            select id, id_value, 
            trim(substring(id_value, 1, POSITION('number' in id_value) +5 )) as value_type, 
            trim(substring(id_value, POSITION('number' in id_value) + 6)) as new_value
            from ad.temp_idents
            where id_value like '%number%'
            and id_value not like '%number'
            and id_value !~ '^[0-9]'
            and id_value !~ '^A[0-9]'
            order by id_value;"#;
    execute_sql(sql, pool).await?;

    // Use that split_numbers table to update the temp_idents table.

    let sql = r#"update ad.temp_idents a
            set id_desc = case 
                when id_desc is null then s.value_type
                else id_desc||', '||s.value_type
                end,
            id_class = case
            when s.value_type ilike '% grant%' then 'OTHER_GRANT'
            when s.value_type ilike '%award%' then 'OTHER_GRANT'
            else 'OTHER' end,
            id_value = s.new_value
            from ad.temp_split_numbers s
            where a.id = s.id;
            drop table if exists ad.temp_split_numbers;"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} Identifier types transferred to id description from value", res.rows_affected());

    // Need to deal with those id values that end with 'number' - no easy way
    // but can simplify a little by first assuring they are all lower case.

    let sql: &'static str = r#"update ad.temp_idents
        set id_value = replace(id_value, 'Number', 'number')
        where id_value ~ 'Number$'"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} Final 'Number's changed to lower case", res.rows_affected());

    switch_number_suffix_to_desc("UPenn IRB Protocol number", pool).await?;
    switch_number_suffix_to_desc("UPittsburgh IRB number", pool).await?;
    switch_number_suffix_to_desc("NIH grant number", pool).await?;
    switch_number_suffix_to_desc("Contract number", pool).await?;
    switch_number_suffix_to_desc("IDRCB number", pool).await?;
    switch_number_suffix_to_desc("UCSD number", pool).await?;
    switch_number_suffix_to_desc("REC number", pool).await?;
    switch_number_suffix_to_desc("REK number", pool).await?;
    switch_number_suffix_to_desc("Station number", pool).await?;
    switch_number_suffix_to_desc("EUDRACT number", pool).await?;
    switch_number_suffix_to_desc("EU CT number", pool).await?;
    switch_number_suffix_to_desc("EudraCT-number", pool).await?;
    switch_number_suffix_to_desc("EudraCT number", pool).await?;
    switch_number_suffix_to_desc("Eudra CT number", pool).await?;
    switch_number_suffix_to_desc("Scripps SOPRS number", pool).await?;
    switch_number_suffix_to_desc("Study number", pool).await?;
    switch_number_suffix_to_desc("Logan IRB number", pool).await?;
    switch_number_suffix_to_desc("Award number", pool).await?;
    switch_number_suffix_to_desc("Sponsor number", pool).await?;
    switch_number_suffix_to_desc("Institution number", pool).await?;
    switch_number_suffix_to_desc("VA IRB number", pool).await?;
    switch_number_suffix_to_desc("Chilean number", pool).await?;
    switch_number_suffix_to_desc("Clinical Trial number", pool).await?;
    switch_number_suffix_to_desc("IMI WP8A number", pool).await?;
    switch_number_suffix_to_desc("UCSF RAS number", pool).await?;
    switch_number_suffix_to_desc("no UCI HS number", pool).await?;
    switch_number_suffix_to_desc("UHN REB number", pool).await?;
    switch_number_suffix_to_desc("CR number", pool).await?;
    switch_number_suffix_to_desc("IRB number", pool).await?;
    switch_number_suffix_to_desc("Hospice number", pool).await?;
    switch_number_suffix_to_desc("Protocol number", pool).await?;
    switch_number_suffix_to_desc("protocol number", pool).await?;
    switch_number_suffix_to_desc("grant number", pool).await?;

    switch_number_suffix_to_desc("MBW-number", pool).await?;
    switch_number_suffix_to_desc("NIAID CRMS ID number", pool).await?;
    switch_number_suffix_to_desc("DDX exemption from MRHA number", pool).await?;
    switch_number_suffix_to_desc("number", pool).await?;
    
    // the last two are odd in that they have an empty Version number suffix, which can be removed

    let sql: &'static str = r#"update ad.temp_idents
        set id_value = replace(id_value, ', Version', '')
        where id_value ~ ', Version$'"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} Empty version numbers removed", res.rows_affected());

    // Repeat removal of spurious 'number 's that simply prefix an identifier

    let sql = r#"update ad.temp_idents
        set id_value = replace(id_value, 'number ', '')
        where id_value ~ '^number ';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} Initial 'number's removed", res.rows_affected());
      
    // clean up beginnings

    remove_leading_char_from_ident('.', pool).await?;
    remove_leading_char_from_ident(':', pool).await?;
    
    // Final trim.

    let sql = r#"update ad.temp_idents
        set id_value = trim(id_value);"#;
    execute_sql(sql, pool).await?;

    info!("");
    Ok(())
}


async fn remove_duplicate_identifiers(pool: &Pool<Postgres>) -> Result<(), AppError> { 

    // Identify duplicated (study id + identifier)s, and link them to the 
    // full identifier records in temp_idents, creating temp_id_dups.
    
    let sql = r#"SET client_min_messages TO WARNING; 
     drop table if exists ad.temp_id_dups;
     create table ad.temp_id_dups as 
        select a.* 
        from ad.temp_idents a
        inner join
            (select sd_sid, id_value
            from ad.temp_idents c
            group by sd_sid, id_value
            having count(id) > 1) d
        on a.sd_sid = d.sd_sid
        and a.id_value = d.id_value
        order by sd_sid, id_value;"#;
    execute_sql(sql, pool).await?;

    // The id_desc field in ad.temp_id_dups 
    // should be updated to include all the id_desc entries for each 
    // set of duplicated records.

    let sql = r#"Update ad.temp_id_dups d
        set id_desc = trim(descs.new_desc)
        from 
            (select sd_sid, id_value, trim(BOTH ',' from trim(string_agg(coalesce(id_desc, ''), ', '))) as new_desc
            from ad.temp_id_dups
            group by sd_sid, id_value) descs
        where d.sd_sid = descs.sd_sid
        and d.id_value = descs.id_value"#;
    execute_sql(sql, pool).await?;
    
    // Create a table of the minimum id records for each duplicate record
    // (Some are duplicated more than once).

    let sql = r#"SET client_min_messages TO WARNING; 
        drop table if exists ad.temp_id_dup_mins;
        create table ad.temp_id_dup_mins as 
        select sd_sid, id_value, id_desc, min(id) as min_id 
        from ad.temp_id_dups 
        group by sd_sid, id_value, id_desc;"#;
    execute_sql(sql, pool).await?;

    // Use the minimum table to update the id_desc field in the main table,
    // of the minimum id records (the ones that will be retained).

    let sql = r#"Update ad.temp_idents a
        set id_desc = m.id_desc
        from ad.temp_id_dup_mins m
        where a.id = m.min_id
        and m.id_desc <> '';"#;
    execute_sql(sql, pool).await?;
   
    // Use the minimum table to remove the minimum id version of each 
    // duplicated record from temp_id_dups.

    let sql = r#"delete from ad.temp_id_dups d
        using ad.temp_id_dup_mins m
        where d.id = m.min_id;"#;
    execute_sql(sql, pool).await?;

    // Use the remaining temp_id_dups records to delete the 
    // spurious records from temp_idents, leaving only the 
    // version with the minimum id in the table.

    let sql = r#"delete from ad.temp_idents c
        using ad.temp_id_dups d
        where c.id = d.id"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} duplicated identifiers removed", res.rows_affected());

    let sql = r#"drop table if exists ad.temp_id_dup_mins;
        drop table if exists ad.temp_id_dups;
        SET client_min_messages TO NOTICE;"#;
    execute_sql(sql, pool).await?;

    // Also remove those records where the identifier is the same as the NCT id.

    let sql = r#"delete from ad.temp_idents 
        where id_value = sd_sid"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} records deleted where identifier = NCT Id", res.rows_affected());

    info!("");
    Ok(())
}


async fn remove_obvious_non_identifiers2(pool: &Pool<Postgres>) -> Result<(), AppError> {  
   
    // Remove a few additional records that now don't have values (or meaningful values).

    let sql = r#"delete from ad.temp_idents i
        where id_value is null
        or id_value = ''
        or id_value ~ '^[0-]+$';"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} Additional empty or meaningless identifier records removed", res.rows_affected());

    // Some records have a digit in the id_desc field and only text (inc. spaces and punctuation)
    // in the id_value field. These are generally where the data in the two fields have been inverted
    // on data entry. These need to be swapped back.

    let sql = r#"update ad.temp_idents
        set id_value = id_desc,
        id_desc = id_value
        where id_value ~ '^[A-Za-z\s\.&,_/#-]+$'
        and id_desc ~ '[0-9]'"#;
    let res = execute_sql(&sql, pool).await?;
    info!("{} identifiers and identifier descriptions reversed", res.rows_affected());

    // Get rid of all remaining identifiers that include only letters, spaces, and punctuation other than hyphens.
    
    let sql = r#"delete from ad.temp_idents
        where id_value ~ '^[A-Za-z\s\.&,_/]+$'"#;
    execute_sql_sfb(sql, pool, "consisting only of letters, spaces, and certain punctuation removed").await?;
    
    // Get rid of a small group that seem to be part of a list of conditions / symptoms

    let sql = r#"delete from ad.temp_idents
        where id_value ~ '^[0-9]\. '
        and id_value !~ '^6. NUP'"#;
    execute_sql_sfb(sql, pool, "that appear to be list items removed").await?;
    
    info!("");
    Ok(())

}


async fn code_very_short_unidentifiable_ids(pool: &Pool<Postgres>) -> Result<(), AppError> { 

    // There are many small identifiers, that if given without any further information,
    // are impossible to characterise as they could have a wide variety of sources.
    // These are categorised as 'unknown' so that can thwm be removed from the temp_idents table,
    // though they ae transferred to study_identifiers. This is just to make later
    // development and processing easier and quicker.
   
    let sql = r#"update ad.temp_idents
        set id_type_id = 990,
        id_type = 'Unknown',
        source_org_id = 12,
        source_org = 'No organisation name provided'
        where id_value ~ '^[0-9]+$'
        and length (id_value) < 7
        and id_desc is null"#;
    execute_sql_sfb(sql, pool, "with only numbers (length < 7) and no description labelled").await?;
    
    let sql = r#"update ad.temp_idents
        set id_type_id = 990,
        id_type = 'Unknown',
        source_org_id = 12,
        source_org = 'No organisation name provided'
        where id_value ~ '^[0-9\-]+$'
        and length (id_value) < 6
        and id_desc is null
        and id_type_id is null"#;
    execute_sql_sfb(sql, pool, "with only numbers and hyphens (length < 6) and no description labelled").await?;

    let sql = r#"update ad.temp_idents
        set id_type_id = 990,
        id_type = 'Unknown',
        source_org_id = 12,
        source_org = 'No organisation name provided'
        where id_value ~ '^[0-9\.]+$'
        and length(id_value) < 6
        and id_desc is null
        and id_type_id is null"#;
    execute_sql_sfb(sql, pool, "with only numbers and periods (length < 6) and no description labelled").await?;

    let sql = r#"update ad.temp_idents
        set id_type_id = 990,
        id_type = 'Unknown',
        source_org_id = 12,
        source_org = 'No organisation name provided'
        where id_value ~ '^[A-Za-z0-9\-]+$'
        and length (id_value) < 5
        and id_desc is null
        and id_type_id is null"#;
    execute_sql_sfb(sql, pool, "with length < 5 and no description labelled").await?;

    info!("");
    Ok(())
}


/*


async fn find_ethics_oversight_identities(_pool: &Pool<Postgres>) -> Result<(), AppError> {  

    Ok(())
}


async fn find_other_identities(pool: &Pool<Postgres>) -> Result<(), AppError> {  

     replace_string_in_ident("EORTC ", "EORTC-", pool).await?;  
    
    let sql = r#"update ad.temp_idents
        set id_source_org = 'sponsor_id',
        id_type_id = 176,
        source_org_id = 100010,
        source_org = 'EORTC'
        where id_value ~ '^EORTC'"#;
    let res1 = execute_sql(sql, pool).await?;
    
    let sql = r#"update ad.temp_idents
        set id_value = substring(id_value from 'EORTC-[0-9]{4,5}'),
        id_source_org = 'sponsor_id',
        id_type_id = 176,
        source_org_id = 100010,
        source_org = 'EORTC'
        where id_value ~ 'EORTC-[0-9]{4,5}'
        and id_type_id is null"#;
    let res2 = execute_sql(sql, pool).await?;

    info!("{} EORTC identifiers found and labelled", res1.rows_affected() + res2.rows_affected());	

    let sql = r#"update ad.temp_idents
        set id_source_org = 'funder_id',
        id_type_id = 410,
        source_org_id = 100517,
        source_org = 'Cancer Research UK'
        where id_value ~ '^CRUK'"#;
    let res = execute_sql(sql, pool).await?;
    info!("{} CRUK identifiers found and labelled", res.rows_affected());	


    // NCI CTEP - NEEDS REDOING  TO IDENTIFY INDIVIDUAL COLLAB GROUPS

    let sql = r#"update ad.temp_idents
        set id_type_id = 175,
        id_type = 'CTEP Number',
        source_org_id = 100162,
        source_org = 'National Cancer Institute'
        where id_desc ~ 'CTEP'"#;

    let res = execute_sql(sql, pool).await?;
    info!("{} NCI CTEP identifiers found and labelled", res.rows_affected());	

        
    let sql = r#"update ad.temp_idents
        set id_type_id = 170,
        id_type = 'NCI PDQ ID',
        source_org_id = 100162,
        source_org = 'National Cancer Institute'
        where id_value ~ '^CAN-NCIC'
        and length(id_value) < 18 ;"#;

    let res2 = execute_sql(sql, pool).await?;
 

    info!("");
    Ok(())
}

*/
